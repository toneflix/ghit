#!/usr/bin/env node
import{createRequire as e}from"node:module";import{Logger as t}from"@h3ravel/shared";import{existsSync as n,mkdirSync as r,writeFileSync as i}from"node:fs";import{fileURLToPath as a}from"node:url";import o,{dirname as s,join as c}from"node:path";import l from"node:readline/promises";import u from"better-sqlite3";import d,{homedir as f,type as p}from"os";import m,{mkdirSync as h}from"fs";import g,{join as _}from"path";import{Octokit as v}from"@octokit/rest";import{Command as y,Kernel as b}from"@h3ravel/musket";import ee from"fast-diff";import{installPackage as te}from"@antfu/install-pkg";import ne from"cli-table3";import{createRequire as re}from"module";import ie from"dns/promises";import{createDeviceCode as ae,exchangeDeviceCode as x}from"@octokit/oauth-methods";import S,{apps as C}from"open";import"dotenv/config";import w from"axios";String.prototype.toKebabCase=function(){return this.replace(/([a-z])([A-Z])/g,`$1-$2`).replace(/[\s_]+/g,`-`).toLowerCase()},String.prototype.toCamelCase=function(){return this.replace(/[-_ ]+([a-zA-Z0-9])/g,(e,t)=>t.toUpperCase()).replace(/^[A-Z]/,e=>e.toLowerCase())},String.prototype.toPascalCase=function(){return this.replace(/(^\w|[-_ ]+\w)/g,e=>e.replace(/[-_ ]+/,``).toUpperCase())},String.prototype.toSnakeCase=function(){return this.replace(/([a-z])([A-Z])/g,`$1_$2`).replace(/[\s-]+/g,`_`).toLowerCase()},String.prototype.toTitleCase=function(){return this.toLowerCase().replace(/(^|\s)\w/g,e=>e.toUpperCase())};let T,E=g.join(f(),`.grithub`);h(E,{recursive:!0});const D=()=>[E,e=>{E=e}],[O,oe]=(()=>[()=>T,e=>{T=new u(g.join(E,e));let[{journal_mode:t}]=T.pragma(`journal_mode`);t!==`wal`&&T.pragma(`journal_mode = WAL`)}])();oe(`app.db`);function k(){return O().exec(`
        CREATE TABLE IF NOT EXISTS json_store (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            key TEXT UNIQUE,
            value TEXT
        )
    `)}function A(e,t){let n=O();return typeof t==`boolean`&&(t=t?`1`:`0`),t instanceof Object&&(t=JSON.stringify(t)),n.prepare(`INSERT INTO json_store (key, value)
        VALUES (?, ?)
        ON CONFLICT(key) DO UPDATE SET value=excluded.value
    `).run(e,t).lastInsertRowid}function j(e){return O().prepare(`DELETE FROM json_store WHERE key = ?`).run(e).lastInsertRowid}function M(e){let t=O();try{let n=t.prepare(`SELECT * FROM json_store WHERE key = ?`).get(e);if(n)try{return JSON.parse(n.value)}catch{return n.value}}catch{}return null}let N;function P(){return[()=>{if(!N)throw Error(`Commander instance has not been initialized`);return N},e=>{N=e}]}function F(){return[()=>M(`config`)||{debug:!1,apiBaseURL:`https://api.github.com`,timeoutDuration:3e3,skipLongCommandGeneration:!0},e=>(A(`config`,e),M(`config`))]}const I=new Set;function L(){return[()=>Array.from(I).filter(e=>!!e),e=>e?I.has(e)?!1:(I.add(e),!0):(I.clear(),!1)]}const R=()=>{let e=M(`token`);if(!e)throw Error(`No authentication token found. Please log in first.`);return new v({auth:e})},z=a(import.meta.url),B=o.dirname(z),V=e=>e.then(e=>[null,e]).catch(e=>[typeof e==`string`?e:e.message,null]);async function H(e,t,n){let r=R(),{data:i,message:a}=await Reflect.apply(r[e][t.api],r[e],[n]);return!i||Array.isArray(i)&&i.length<1||i instanceof Object&&Object.keys(i).length<1?{data:null,message:a??`Request was successful but returned no data.`,status:!1}:{data:i,message:a??`Request Completed`,status:!0}}const U=(e,t)=>new Promise(n=>{setTimeout(()=>{t&&n(t()),n()},e)}),W=(e,n=[`green`,`italic`],r)=>t.log(e,n,r??!1),G=e=>{t.log([[`Title:`,[`white`,`bold`]],[e.title,[`blue`]],[`
Type:`,[`white`,`bold`]],[typeof e.type==`string`?e.type:e.type?.name??`N/A`,[`blue`]],[`
Number:`,[`white`,`bold`]],[String(e.number),[`blue`]],[`
State:`,[`white`,`bold`]],[e.state,[`blue`]],[`
Labels:`,[`white`,`bold`]],[e.labels.map(e=>e.name??e).join(`, `),[`blue`]],[`
Assignees:`,[`white`,`bold`]],[e.assignees?.map(e=>e.login??e).join(`, `)||`N/A`,[`blue`]],[`
Created at:`,[`white`,`bold`]],[new Date(e.created_at).toLocaleString(),[`blue`]],[`
Updated at:`,[`white`,`bold`]],[new Date(e.updated_at).toLocaleString(),[`blue`]]],` `)},K=(e=B)=>{let t=e;for(;;){let e=o.join(t,`package.json`);if(n(e))return e;let r=o.dirname(t);if(r===t)break;t=r}return null},q=async e=>{let t=l.createInterface({input:process.stdin,output:process.stdout});await t.question(``),e(),t.close()};var se={issues:[{api:`create`,alias:void 0,endpoint:`/repos/{owner}/{repo}/issues`,description:`Create an issue`,params:[{parameter:`title`,required:!0,type:`String`,description:`The title of the issue`,paramType:`body`,flag:!0},{parameter:`body`,required:!1,type:`String`,description:`The contents of the issue`,paramType:`body`,flag:!0},{parameter:`owner`,required:!1,type:`String`,description:`The account owner of the repository`,paramType:`path`,arg:!0},{parameter:`repo`,required:!1,type:`String`,description:`The name of the repository`,paramType:`path`,arg:!0}]},{api:`listForRepo`,alias:`list`,endpoint:`/repos/{owner}/{repo}/issues`,description:`List repository issues`,params:[{parameter:`owner`,required:!1,type:`String`,description:`The account owner of the repository`,paramType:`path`},{parameter:`repo`,required:!1,type:`String`,description:`The name of the repository`,paramType:`path`},{parameter:`state`,required:!1,type:`String`,description:`Indicates the state of the issues to return. [open, closed]`,paramType:`query`}]},{api:`get`,alias:`get`,endpoint:`/repos/{owner}/{repo}/issues/{issue_number}`,description:`Get a single issue`,params:[{parameter:`issue_number`,required:!0,type:`Number`,description:`The number of the issue to get`,paramType:`path`},{parameter:`owner`,required:!1,type:`String`,description:`The account owner of the repository`,paramType:`path`},{parameter:`repo`,required:!1,type:`String`,description:`The name of the repository`,paramType:`path`}]}],orgs:[{api:`listForAuthenticatedUser`,alias:`list`,endpoint:`/user/orgs`,description:`List organizations for the authenticated user`,params:[{parameter:`page`,required:!1,type:`Number`,description:`Page number of the results to fetch`,paramType:`query`},{parameter:`per_page`,required:!1,type:`Number`,description:`Results per page (max 100)`,paramType:`query`}]}]};const ce=(e,t)=>{let[n,r]=L(),i=``;if((!e.required||e.default!==void 0||e.type===`Boolean`||e.options||e.flag===!0)&&e.paramType!==`path`&&e.arg!==!0){if(i+=`{--`,r(t+`:`+e.parameter.charAt(0).toLowerCase()))i+=`${e.parameter.charAt(0).toLowerCase()}|`;else{let n=e.parameter.split(/[_-\s]/);n.length>1&&r(t+`:`+n[1].charAt(0).toLowerCase())&&(i+=`${n[1].charAt(0).toLowerCase()}|`)}if(i+=`${e.parameter}`,e.type!==`Boolean`&&(i+=e.default?`=${e.default}`:`?`),e.description&&(i+=` : ${e.description}`),e.options){let t=e.options.join(`,`);i+=` : ${t}`}i+=`}`}else i+=`{${e.parameter}`,e.default&&(i+=`=${e.default}`),e.description&&(i+=` : ${e.description}`),i+=`}`;return i},le=e=>{let n=(e,r=0)=>{let i=` `.repeat(r);for(let a in e){let o=e[a];if(typeof o==`object`&&o)console.log(`${i}${J(a)}:`),n(o,r+2);else{let e;switch(typeof o){case`string`:e=t.log(o,`green`,!1);break;case`number`:e=t.log(String(o),`yellow`,!1);break;case`boolean`:e=t.log(String(o),`blue`,!1);break;case`object`:e=o===null?t.log(`null`,`gray`,!1):t.log(JSON.stringify(o),`cyan`,!1);break;default:e=o}console.log(`${i}${J(a)}: ${e}`)}}};n(e)},J=e=>e.replace(/([a-z])([A-Z])/g,`$1 $2`).replace(/[_-]+/g,` `).replace(/\s+/g,` `).split(` `).map(e=>e.charAt(0).toUpperCase()+e.slice(1)).join(` `).trim().replace(/^(\w{2})$/,(e,t)=>t.toUpperCase()),ue=(e,t)=>ee(t,e).map(e=>{let[t,n]=e;return t===0?n:t===-1?W(n,[`red`,`strikethrough`],!1):W(n,[`green`,`underline`],!1)}).join(``);var de=()=>{let t=e(import.meta.url),r=[],i=se;!process.argv.includes(`generate:apis`)&&n(o.join(process.cwd(),`.grithub/apis.generated.js`))&&({APIs:i}=t(o.join(process.cwd(),`.grithub/apis.generated.js`)));let a=Object.entries(i).reduce((e,[t,n])=>(n.forEach(n=>{let r=t===n.api?t:`${t}:${(n.alias??n.api).toKebabCase()}`;e[r]=n}),e),{});for(let[e,t]of Object.entries(a)){let n=t.params.map(t=>ce(t,e)).join(`
`),i=class extends y{signature=`${e} \n${n}`;description=t.description||`No description available.`;handle=async()=>{let n=e.split(`:`).shift(),r={...this.arguments()??{},...this.options()??{}},[i,a]=P();if(a(this),!n)return void this.error(`Unknown command entry.`).newLine();for(let e of t.params)if(e.required&&!this.argument(e.parameter))return void this.newLine().error(`Missing required argument: ${e.parameter}`).newLine();let o=M(`default_repo`),s=M(`token`),c=([r.owner,r.repo].filter(Boolean).join(`/`)||o.full_name).split(`/`)??[``,``],l=t.params.some(e=>[`repo`,`user`].includes(e.parameter));if(l&&(!c[0]||!c[1]))return void this.error(`ERROR: No repository set. Please set a default repository using the [set-repo] command or provide one using the --repo option.`).newLine();if(!s)return void this.error(`ERROR: You're not signed in, please run the [login] command before you begin`).newLine();this.newLine();let u=this.spinner(`Loading...
`).start();l&&(r.owner=c[0],r.repo=c[1]);let[d,f]=await V(H(n,t,r));if(d||!f)return void u.fail((d||`An error occurred`)+`
`);u.succeed(f.message),this.newLine(),le(f.data),this.newLine()}};r.push(i)}return r};const fe=e=>[{name:`Debug Mode`,value:`debug`,description:`Enable or disable debug mode (${e.debug?`Enabled`:`Disabled`})`},{name:`API Base URL`,value:`apiBaseURL`,description:`Set the base URL for the API (${e.apiBaseURL})`},{name:`Timeout Duration`,value:`timeoutDuration`,description:`Set the timeout duration for API requests (${e.timeoutDuration} ms)`},{name:`Skip Long Command Generation`,value:`skipLongCommandGeneration`,description:`Enable or disable skipping of long command generation when calling ${W(`generate:apis`,[`grey`,`italic`])} (${e.skipLongCommandGeneration?`Enabled`:`Disabled`})`},{name:`Ngrok Auth Token`,value:`ngrokAuthToken`,description:`Set the Ngrok Auth Token - will default to environment variable if not set (${e.ngrokAuthToken?`************`:`Not Set`})`},{name:`Reset Configuration`,value:`reset`,description:`Reset all configurations to default values`}],pe=async e=>{let[t,n]=F(),[r]=P(),i=t();if(e===`debug`){let e=await r().confirm(`${i.debug?`Dis`:`En`}able debug mode?`,i.debug===!0);i.debug=i.debug!==e}else if(e===`apiBaseURL`)i.apiBaseURL=await r().ask(`Enter API Base URL`,i.apiBaseURL);else if(e===`ngrokAuthToken`)i.ngrokAuthToken=await r().ask(`Enter Ngrok Auth Token`,i.ngrokAuthToken||``);else if(e===`timeoutDuration`){let e=await r().ask(`Enter Timeout Duration (in ms)`,i.timeoutDuration.toString());i.timeoutDuration=parseInt(e)}else e===`skipLongCommandGeneration`?i.skipLongCommandGeneration=await r().confirm(`${i.skipLongCommandGeneration?`Dis`:`En`}able skipping of long command generation?`,i.skipLongCommandGeneration===!0):e===`reset`&&(i={debug:!1,apiBaseURL:`https://api.github.com`,timeoutDuration:3e3,skipLongCommandGeneration:!0});n(i)};var me=class extends y{signature=`config`;description=`Configure Grithub`;async handle(){let[e,t]=P();t(this);let[n,r]=F(),i=n();i||(i={debug:!1,apiBaseURL:`https://api.github.com`,timeoutDuration:3e3,skipLongCommandGeneration:!0},r(i)),await pe(await this.choice(`Select configuration to set`,fe(i))),this.info(`Configuration updated successfully!`).newLine()}},he=class e{spec;config;openapi;skipApis=new Set([`issues:list`,`issues:update`,`issues:seed`,`issues:delete`]);skipParams=new Set([`s`]);PARAM_LOCATIONS=new Set([`path`,`query`,`header`]);constructor(e,t=`api.github.com.deref`){let[n]=F();if(this.openapi=e,this.spec=this.openapi.schemas[t],this.config=n(),!this.spec||!this.spec.paths)throw Error(`Could not find ${t} schema`)}static async installOctokitOpenapi(){let e=P()[0]().spinner(`Installing @octokit/openapi...`).start(),t=s(a(import.meta.url));return await te(`@octokit/openapi`,{cwd:o.normalize(o.join(t,`../..`)),silent:!0,dev:!0}),e.succeed(`@octokit/openapi installed successfully.`),(await import(`@octokit/openapi`)).default}skipParam(e){return this.skipParams.has(e)||e.length>20||e.length<=2}skipApi(e,t){let n=(t?t+`:`:``)+e.toCamelCase();return this.skipApis.has(n)||this.skipApis.has(e.toCamelCase())||n.length>(this.config.skipLongCommandGeneration?23:1/0)}normalizeType(e){let t={integer:`Number`,number:`Number`,string:`String`,boolean:`Boolean`,array:`Array`,object:`Object`,enum:`String`,oneOf:`String`,anyOf:`String`,allOf:`String`},n=t[e?.type]||`any`;return Array.isArray(e?.type)&&(n=e.type.map(e=>t[e]||`any`).join(`|`)),n===`any`?(e||(n=`any`),Array.isArray(e.type)?e.type.join(`|`):(e.type&&(n=e.type),e.enum&&(n=`enum`),e.oneOf&&(n=`oneOf`),e.anyOf&&(n=`anyOf`),e.allOf&&(n=`allOf`),t[n]||`any`)):n}gatherParams(e){let t=[];for(let n of e.parameters??[]){let e=this.PARAM_LOCATIONS.has(n.in)?n.in:`query`;this.skipParam(n.name)||t.push({parameter:n.name,required:!!n.required,type:this.normalizeType(n.schema).toPascalCase(),description:n.description,paramType:e})}let n=e.requestBody?.content?.[`application/json`],r=n?.schema,i=r?.properties??{},a=r?.required??[];for(let[e,r]of Object.entries(i))this.skipParam(e)||t.push({parameter:e,required:a.includes(e)||!!n?.required,type:this.normalizeType(r).toPascalCase(),description:r.description,paramType:`body`});return t}buildTree(){let e={};for(let[t,n]of Object.entries(this.spec.paths))for(let[r,i]of Object.entries(n??{})){let n=i,r=n?.operationId;if(!r)continue;let[a,o]=r.split(`/`);if(!a||!o||this.skipApi(o,a))continue;let s=this.gatherParams(n);e[a.toCamelCase()]||(e[a.toCamelCase()]=[]),e[a.toCamelCase()].push({api:o.toCamelCase(),endpoint:t,description:n.summary??n.description??void 0,alias:n[`x-github`]?.alias??n[`x-octokit`]?.alias??void 0,params:s})}return e}static async run(){let[t]=P(),n=t(),a,s=n.spinner(`Checking if @octokit/openapi Installed...`).start();try{({default:a}=await import(`@octokit/openapi`)),s.succeed(`@octokit/openapi is already installed.`)}catch{s.fail(`@octokit/openapi is not installed.`),a=await e.installOctokitOpenapi()}s.start(`Generating Extended APIs...`);let c=new e(a,`api.github.com.deref`).buildTree(),l=o.join(process.cwd(),`.grithub/apis.generated.js`),u=`// Auto-generated from @octokit/openapi. Do not edit directly.

export const APIs = ${JSON.stringify(c,null,2).replace(/"([A-Za-z_][\w$]*)":/g,`$1:`).replace(/:\s*"((?:[^"\\]|\\.)*)"/g,(e,t)=>`: '${t.replace(/\\"/g,`"`).replace(/'/g,`\\'`)}'`)}\n\nexport default APIs\n`;r(o.dirname(l),{recursive:!0}),i(l,u,`utf8`),s.succeed(`Generated Extended APIs to: `+l)}},ge=class extends y{signature=`generate:apis`;description=`Generate extended API definitions from the GitHub OpenAPI spec`;async handle(){let[e,t]=P();t(this),he.run()}},_e=class extends y{signature=`info`;description=`Display application runtime information.`;async handle(){let e={version:`unknown`,dependencies:{}},n=M(`user`),r=K(),i=re(import.meta.url),[a,o]=P(),[s]=D();o(this),k();let c=this.spinner(`Gathering application information...
`).start();if(r)try{e=i(r)}catch{}U(500,()=>{c.succeed(`Application Information Loaded.
`);let r=new ne;r.push({"App Version":e.version},{Platform:`${d.platform()} ${d.arch()} (${d.release()})`},{CPUs:d.cpus().length},{Host:`${d.userInfo().username}@${d.hostname()}`},{Memory:`${(d.freemem()/1024**3).toFixed(2)} GB / ${(d.totalmem()/1024**3).toFixed(2)} GB`},{"Database Path":g.join(s,`app.db`)},{"Github User":n?`${n.login} (ID: ${n.id})`:`Not logged in`},{"Default Repo":M(`default_repo`)?.full_name||`Not set`}),console.log(r.toString()),t.log(`
Dependencies:`,`yellow`),t.log(Object.keys(e.dependencies).map(e=>`${e}`).join(`, `),`green`),this.newLine()})}},ve=class extends y{signature=`init`;description=`Initialize the application.`;async handle(){let[e,t]=P();t(this),k(),this.info(`Application initialized successfully.`).newLine()}},Y=class{command;constructor(){let[e]=P();this.command=e()}setFilePath(e,t){return t&&(e=e.includes(`<!-- grithub#filepath:`)?e.replace(/<!--\s*grithub#filepath:\s*.+?\s*-->/i,`<!-- grithub#filepath: ${t} -->`):`<!-- grithub#filepath: ${t} -->\n\n`+e),e}getFilePath(e){let t=e.match(/<!--\s*grithub#filepath:\s*(.+?)\s*-->/i);if(t)return t[1].trim()}parseFrontmatter(e){let t=e.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);if(!t)return{metadata:{},body:e};let[,n,r]=t,i={},a=n.split(`
`),o=null;for(let e of a){let t=e.match(/^(\w+):\s*['"]?(.*?)['"]?$/);if(t){let[,e,n]=t;o=e,i[e]=n}else o&&e.trim()&&(i[o]+=`
`+e.trim())}return{metadata:i,body:r.trim()}}async updateIssue(e,t,n,r){try{let{data:i}=await R().issues.update({repo:r,owner:n,issue_number:t.number,body:this.setFilePath(e.body,e.filePath),title:e.title,labels:e.labels||[],assignees:e.assignees||[]});return i}catch(e){throw this.requestError(e,n,r)}}async createIssue(e,t,n){try{let{data:r}=await R().issues.create({repo:n,owner:t,type:e.type,body:this.setFilePath(e.body,e.filePath),title:e.title,labels:e.labels||[],assignees:e.assignees||[]});return r}catch(e){throw this.requestError(e,t,n)}}getIssueFiles(e){let t=[],n=this.command.spinner(`Reading issue files...`).start(),r=e=>{let n=m.readdirSync(e,{withFileTypes:!0});for(let i of n){let n=g.join(e,i.name);i.isDirectory()?r(n):i.isFile()&&i.name.endsWith(`.md`)&&t.push(n)}};r(e);let i=t.sort();return n.succeed(`Found ${i.length} issue files`),i.length===0&&(n.info(`No issue files found. Exiting.`),process.exit(0)),i}processIssueFile(e){let t=_(process.cwd(),this.command.argument(`directory`,`issues`)),n=m.readFileSync(e,`utf-8`),{metadata:r,body:i}=this.parseFrontmatter(n),a=g.relative(t,e),o=g.basename(e,`.md`),s=[];r.labels&&(s=r.labels.split(`,`).map(e=>e.trim()).filter(e=>e));let c=[];return r.assignees&&r.assignees.trim()&&(c=r.assignees.split(`,`).map(e=>e.trim()).filter(e=>e)),{filePath:a,title:r.title||r.name||o,type:r.type,body:i,labels:s,assignees:c,fileName:o}}async validateAccess(e,t){let n=this.command.spinner(`Checking GitHub access...`).start();try{return await R().repos.get({owner:e,repo:t})}catch(e){n.stop();let t=``;throw t=e.status===404?`ERROR: ${e.message}\n\nThis usually means:
  1. No internet connection
  2. DNS server issues
  3. Firewall/proxy blocking DNS

Troubleshooting:
  - Check your internet connection
  - Try opening https://github.com in your browser
  - If behind a corporate firewall, check proxy settings
  - Try using a different DNS (e.g., 8.8.8.8)

Original error: ${e.message}`:`ERROR: GitHub access validation failed: ${e.message}`,Error(t)}finally{n.succeed(`GitHub access validated successfully.`)}}async checkConnectivity(){let e=this.command.spinner(`Checking network connectivity...`).start();try{let n=await ie.resolve(`api.github.com`);return e.succeed(`DNS resolution successful: ${t.log(n[0],`blue`,!1)}`),n}catch(t){throw e.stop(),Error(`ERROR: Cannot resolve api.github.com

This usually means:
  1. No internet connection
  2. DNS server issues
  3. Firewall/proxy blocking DNS

Troubleshooting:
  - Check your internet connection
  - Try opening https://github.com in your browser
  - If behind a corporate firewall, check proxy settings
  - Try using a different DNS (e.g., 8.8.8.8)

Original error: ${t.message}`)}}async fetchExistingIssues(e,t,n){let r=[],i=1,a=!0,o=this.command.spinner(`Fetching existing open issues...`).start();for(;a;)try{let{data:s}=await R().issues.listForRepo({owner:e,repo:t,state:n||`open`,per_page:100,page:i});r.push(...s.filter(e=>!e.pull_request)),o.stop(),a=r.length%100==0&&s.length===100,a?i++:a=!1}catch(e){a=!1,o.stop(),this.command.warn(`ERROR: Failed to fetch existing issues: ${e.message}`),this.command.warn(`INFO: Proceeding without duplicate check...`)}return o.succeed(`Found ${r.length} existing issues.`),r}requestError(e,n,r){let i=e.message||`GitHub API error`;return e.status===401?(i+=`

This is an authentication error. Check that:`,i+=`\n  1. You are logged in (make sure to run the ${t.log(`login`,[`grey`,`italic`],!1)}`,i+=`command first)`,i+=`
  2. The app token has "repo" scope`,i+=`
  3. The app token hasn't expired`):e.status===404?(i+=`

Repository not found. Check that:`,n&&(i+=`\n  1. ${t.log(n,[`blue`,`bold`],!1)} is a valid gitHub username or organization`),r&&(i+=`\n  2. ${t.log(r,[`blue`,`bold`],!1)} is the correct repository name`),i+=`
  3. You have access to this repository`):e.status===422&&(i+=`

Validation failed. This usually means:`,i+=`
  1. Issue data format is invalid`,i+=`
  2. Labels don't exist in the repository`,i+=`
  3. Assignees don't have access to the repository`),Error(i)}};const X=async(e,t,n,r)=>{let i=R(),a=r;a||({repository:{issue:{id:a}}}=await i.graphql(`
            query ($owner: String!, $repo: String!, $issue_number: Int!) {
                repository(owner: $owner, name: $repo) {
                    issue(number: $issue_number) {
                        id
                    }
                }
            }
        `,{owner:e,repo:t,issue_number:n})),await i.graphql(`
        mutation ($issueId: ID!) {
            deleteIssue(input: {issueId: $issueId}) {
                clientMutationId
            }
        }
    `,{issueId:a})};var ye=class extends y{signature=`issues
        { repo? : The full name of the repository (e.g., username/repo)}
    `;description=`Manage issues in the default repository.`;async handle(){let[e,t]=P();t(this);let n=M(`default_repo`),r=this.argument(`repo`,n.full_name).split(`/`)??[``,``],i=this.spinner(`Fetching issues...`).start();try{let e=1,t=[];do{let n=await this.loadIssues(r,e);t.push(...n),i.succeed(`${t.length} issues fetched successfully.`);let a=await this.choice(`Select Issue`,t.map(e=>({name:`#${e.number}: ${e.state===`open`?`üü¢`:`üî¥`} ${e.title}`,value:String(e.number)})).concat(t.length===20?[{name:`Load more issues`,value:`>>`}]:[]),0);if(a===`>>`)e++;else{let e=t.find(e=>String(e.number)===a);this.info(`#${e.number}: ${e.title}`).newLine();let n=await this.choice(`Choose Action`,[{name:`View Details`,value:`view`},e.closed_at?null:{name:`Close Issue`,value:`close`},e.closed_at?{name:`Reopen Issue`,value:`reopen`}:null,{name:`Edit Issue`,value:`edit`},{name:W(`Delete Issue`,[`red`,`italic`]),value:`delete`},{name:`Exit`,value:`exit`}].filter(e=>!!e),0);if(n===`view`)G(e),this.newLine();else if(n===`close`)e.state===`closed`?this.warn(`Issue is already closed.`).newLine():(i.start(`Closing issue #${e.number}...`),await R().issues.update({owner:r[0],repo:r[1],issue_number:e.number,state:`closed`}),i.succeed(`Issue #${e.number} closed successfully.`));else if(n===`reopen`)e.state===`open`?this.warn(`Issue is already open.`).newLine():(i.start(`Reopening issue #${e.number}...`),await R().issues.update({owner:r[0],repo:r[1],issue_number:e.number,state:`open`}),i.succeed(`Issue #${e.number} reopened successfully.`));else if(n===`edit`){let t=await this.choice(`What do you want to edit?`,[{name:`Title`,value:`title`},{name:`Body`,value:`body`}],0);if(t===`exit`)return;let n={};if(t===`title`?n.title=await this.ask(`Enter new title:`,e.title):t===`body`&&(n.body=await this.editor(`Edit issue body:`,`.md`,e.body??``)),Object.keys(n).length>0){let t=new Y;i.start(`Updating issue #${e.number}...`),await t.updateIssue(Object.assign({labels:e.labels,assignees:e.assignees},n),e,...r),i.succeed(`Issue #${e.number} updated successfully.`)}else this.info(`No changes made to the issue.`).newLine()}else if(n===`delete`)i.start(`Deleting issue #${e.number}...`),await X(r[0],r[1],e.number,e.node_id),i.succeed(`Issue #${e.number} deleted successfully.`);else if(n===`exit`)return;return}}while(t.length===20)}catch(e){i.stop(),this.error(e.message);return}}async loadIssues(e,t=1){let n=[];return{data:n}=await R().issues.listForRepo({page:t,repo:e[1],owner:e[0],per_page:20,state:`all`}),n.filter(e=>!e.pull_request)}},be=class extends y{signature=`issues:delete
        { repo? : The full name of the repository (e.g., username/repo)}
        {--dry-run : Simulate the deletion without actually deleting issues.}
    `;description=`Delete issues from the specified repository.`;async handle(){let[e,t]=P();t(this);let n=M(`default_repo`),r=this.argument(`repo`,n.full_name).split(`/`)??[``,``],i=this.spinner(`Fetching issues...`).start(),a=this.option(`dryRun`,!1);try{let e=await this.loadIssues(r);i.succeed(`${e.length} issues fetched successfully.`);let t=await this.checkbox(`Select Issue${a?` (Dry Run)`:``}`,e.map(e=>({name:`#${e.number}: ${e.state===`open`?`üü¢`:`üî¥`} ${e.title}`,value:String(e.number)})),!0,void 0,20);if(!await this.confirm(`Are you sure you want to delete the selected ${t.length} issue(s)? ${a?`(Dry Run - No changes will be made)`:`This action cannot be undone`}.`)){this.info(`Operation cancelled.`);return}for(let n of e.filter(e=>t.includes(String(e.number))))i.start(`Deleting issue #${n.number}...`),a?i.info(`Dry run: Issue #${n.number} would be deleted.`):(await X(r[0],r[1],n.number,n.node_id),i.succeed(`Issue #${n.number} deleted successfully.`));this.success(`${t.length} issue(s) deleted successfully.`)}catch(e){i.stop(),this.error(e.message);return}}async loadIssues(e){let t=[];return{data:t}=await R().issues.listForRepo({repo:e[1],owner:e[0],per_page:20,state:`all`}),t.filter(e=>!e.pull_request)}},xe=class extends y{signature=`issues:seed
        {directory=issues : The directory containing issue files to seed from.}
        {--r|repo? : The repository to seed issues into. If not provided, the default repository will be used.}
        {--dry-run : Simulate the deletion without actually deleting issues.}
    `;description=`Seed the database with issues from a preset directory.`;async handle(){let[e,r]=P();r(this);let i=c(process.cwd(),this.argument(`directory`,`issues`)),a=this.option(`dryRun`,!1),o=M(`default_repo`);if(!o)return void this.error(`ERROR: No default repository set. Please set a default repository using the ${W(`set-repo`,[`grey`,`italic`])} command.`);let s=new Y;try{let e=this.option(`repo`,o.full_name).split(`/`)??[``,``];if(await s.checkConnectivity(),await s.validateAccess(...e),!n(i)){this.error(`ERROR: Issues directory not found: ${W(i,[`grey`,`italic`])}`);return}let r=s.getIssueFiles(i),c=await s.fetchExistingIssues(...e,`all`),l=new Set(c.map(e=>s.getFilePath(e.body??``))),u=r.map(s.processIssueFile.bind(s)).filter(Boolean),d=[],f=[];if(u.forEach(e=>{if(l.has(e.filePath)){let t=c.find(t=>t.title.toLowerCase()===e.title.toLowerCase());f.push({issue:e,existingIssue:t})}else d.push(e)}),f.length>0&&(this.newLine().info(`INFO: Issues to SKIP (already exist):`),f.forEach(({issue:e,existingIssue:t})=>{W(`  >  ${e.title}`,`white`,!0),W(`     Existing: #${t.number} (${t.state})`,`white`,!0)})),d.length>0)this.newLine().info(`INFO: Issues to CREATE:`).newLine(),d.forEach((e,t)=>{W(`${t+1}. ${e.title}`,`white`,!0)}),this.newLine();else{this.newLine().success(`INFO: No new issues to create. All issues already exist`).newLine(),t.log([[`‚òë Total files:`,`white`],[u.length.toString(),`blue`]],` `),t.log([[`> Skipped:`,`white`],[f.length.toString(),`blue`]],` `),t.log([[`¬± To create:`,`white`],[d.length.toString(),`blue`]],` `),this.newLine();return}if(t.log([[`‚ö†Ô∏è `,`white`],[` CONFIRM `,`bgYellow`],[`This will create`,`yellow`],[d.length.toString(),`blue`],[`new issues on GitHub.`,`yellow`]],` `),f.length>0&&this.info(`(Skipping ${f.length} existing issues)`),await this.confirm(`Do you want to proceed?${a?` (Dry Run - No changes will be made)`:``}`)){this.newLine();let n=0,r=0,i=this.spinner(`Creating issues...`).start();for(let t of d)try{if(i.start(`Creating: ${t.title}...`),a)i.info(`Dry run: Issue ${W(t.title,[`cyan`,`italic`])} would be created.`);else{let n=await s.createIssue(t,...e);i.succeed(`Created #${n.number}: ${n.title}`),this.info(`URL: ${n.html_url}\n`)}n++,await U(1e3)}catch(e){this.error(`ERROR: Failed to create Issue: ${W(t.title,[`cyan`,`italic`])}`),this.error(`ERROR: ${e.message}\n`),r++}i.succeed(`All ${d.length} issues processed.`),t.log([[`=========================`,`white`],[`‚úî Created: ${n}`,`white`],[`x Failed: ${r}`,`white`],[`> Skipped: ${f.length}`,`white`],[`‚òë Total: ${u.length}`,`white`],[`========================`,`white`]],`
`),this.newLine()}}catch(e){this.error(e.message);return}}},Se=class extends y{signature=`issues:update
        {directory=issues : The directory containing issue files to seed from.}
        {--r|repo? : The repository to seed issues into. If not provided, the default repository will be used.}
        {--dry-run : Simulate the deletion without actually deleting issues.}
    `;description=`Seed the database with updated issues from a preset directory.`;async handle(){let[e,r]=P();r(this);let i=c(process.cwd(),this.argument(`directory`,`issues`)),a=this.option(`dryRun`,!1),o=M(`default_repo`);if(!o)return void this.error(`ERROR: No default repository set. Please set a default repository using the ${W(`set-repo`,[`grey`,`italic`])} command.`);let s=new Y;try{let e=this.option(`repo`,o.full_name).split(`/`)??[``,``];if(await s.checkConnectivity(),await s.validateAccess(...e),!n(i)){this.error(`ERROR: Issues directory not found: ${W(i,[`grey`,`italic`])}`);return}let r=s.getIssueFiles(i),c=await s.fetchExistingIssues(...e,`all`),l=new Set(c.map(e=>s.getFilePath(e.body??``))),u=r.map(s.processIssueFile.bind(s)).filter(Boolean),d=[],f=[];if(u.forEach(e=>{if(l.has(e.filePath)){let t=c.find(t=>s.getFilePath(t.body??``)===e.filePath);f.push({issue:e,existingIssue:t})}else d.push(e)}),d.length>0&&(this.newLine().info(`INFO: Issues to SKIP (not created):`),d.forEach((e,t)=>{W(`${t+1}. ${e.title}`,`white`,!0),W(`   File: ${e.filePath} (${e.type})`,`white`,!0)})),f.length>0)this.newLine().info(`INFO: Issues to UPDATE:`).newLine(),f.forEach(({issue:e,existingIssue:t})=>{W(`  >  ${ue(e.title,t.title)}`,`white`,!0),W(`     Existing: #${t.number} (${t.state})`,`white`,!0)}),this.newLine();else{this.newLine().success(`INFO: No issues to update. All issues are up to date`).newLine(),t.log([[`‚òë Total files:`,`white`],[u.length.toString(),`blue`]],` `),t.log([[`> Skipped:`,`white`],[d.length.toString(),`blue`]],` `),t.log([[`¬± To update:`,`white`],[f.length.toString(),`blue`]],` `),this.newLine();return}if(t.log([[`‚ö†Ô∏è `,`white`],[` CONFIRM `,`bgYellow`],[`This will update`,`yellow`],[f.length.toString(),`blue`],[`existing issues on GitHub.`,`yellow`]],` `),d.length>0&&this.info(`(Skipping ${d.length} existing issues)`),await this.confirm(`Do you want to proceed?${a?` (Dry Run - No changes will be made)`:``}`)){this.newLine();let n=0,r=0,i=this.spinner(`Updating issues...`).start();for(let{issue:t,existingIssue:o}of f)try{if(i.start(`Updating: ${t.title}...`),a)i.info(`Dry run: Issue ${W(t.title,[`cyan`,`italic`])} would be updated.`);else{let n=await s.updateIssue(t,o,...e);i.succeed(`Updated #${n.number}: ${n.title}`),this.info(`URL: ${n.html_url}\n`)}n++,await U(1e3)}catch(e){this.error(`ERROR: Failed to update Issue: ${W(t.title,[`cyan`,`italic`])}`),this.error(`ERROR: ${e.message}\n`),r++}i.succeed(`All ${f.length} issues processed.`),t.log([[`=========================`,`white`],[`‚úî Updated: ${n}`,`white`],[`x Failed: ${r}`,`white`],[`> Skipped: ${d.length}`,`white`],[`‚òë Total: ${u.length}`,`white`],[`========================`,`white`]],`
`),this.newLine()}}catch(e){this.error(e.message);return}}};const Z={CLIENT_ID:`6+63+123+122+37+32+17+56+112+6+14+0+125+7+31+10+122+58+42+39`.split(`+`).map(e=>String.fromCharCode(Number(e)^73)).join(``),CLIENT_TYPE:`oauth-app`,SCOPES:[`repo`,`read:user`,`user:email`]};async function Ce(){let[e]=P(),n=e(),r=n.spinner(`Requesting device code...`).start();try{let{data:{device_code:e,user_code:i,verification_uri:a,interval:o}}=await ae({clientType:Z.CLIENT_TYPE,clientId:Z.CLIENT_ID,scopes:Z.SCOPES});r.succeed(`Device code created`),t.log([[`Your authentication code is`,`white`],[`\n\t ${i} \n`,[`white`,`bgBlue`]]],` `),t.log([[`Please open the following URL in your browser to authenticate:`,`white`],[a,[`cyan`,`underline`]]],` `),t.log([[`Press Enter to open your browser, or `,`white`],[`Ctrl+C`,[`grey`,`italic`]],[` to cancel`,`white`]],` `),await q(async()=>{try{p()===`Windows_NT`?await S(a,{wait:!0,app:{name:C.browser}}):await S(a,{wait:!0})}catch(e){n.error(`Error opening browser:`+e.message),n.info(`Please manually open the following URL in your browser:`),n.info(a),await U(3e3)}});let s=o,c=150;for(r=n.spinner(`Waiting for authorization...`).start();;){if(--c,c<0)throw Error(`User took too long to respond`);try{let{authentication:t}=await x({clientType:`oauth-app`,clientId:Z.CLIENT_ID,code:e,scopes:Z.SCOPES}),{data:n}=await new v({auth:t.token}).request(`/user`);return r!==void 0&&r.succeed(`Authorization successful`),{authentication:t,user:n}}catch(e){if(e.status===400){let t=e.response.data.error;if([`authorization_pending`,`slow_down`].includes(t))await U(s*3e3);else if([`expired_token`,`incorrect_device_code`,`access_denied`].includes(t))throw Error(t);else throw Error(`An unexpected error occurred: ${e.message}`)}else throw Error(`An unexpected error occurred: ${e.message}`)}}}catch{return Z.CLIENT_ID?r.fail(`Failed to authenticate user`):r.fail(`GitHub Client ID not available.`),null}}function we({authentication:e,user:t}){A(`user`,t),A(`token`,e.token),A(`scopes`,e.scopes),A(`clientId`,e.clientId),A(`clientType`,e.clientType)}function Q(){j(`token`),j(`scopes`),j(`clientId`),j(`clientType`)}var Te=class extends y{signature=`login`;description=`Log in to Grithub`;async handle(){let[e,n]=P();n(this);let r=M(`token`),i;if(r){this.info(`INFO: You're already logged in`).newLine();return}else{let[e,t]=await V(Ce());t&&(we(t),r=M(`token`),i=M(`user`))}if(r&&i){let e=await R().rest.repos.listForAuthenticatedUser(),n=await this.choice(`Select default repository`,e.data.map(e=>({name:e.full_name,value:e.full_name})),0),r=e.data.find(e=>e.full_name===n);r?A(`default_repo`,{id:r.id,name:r.name,full_name:r.full_name,private:r.private}):A(`default_repo`,{}),this.info(`INFO: You have been logged in as ${t.log(i.name,`blue`,!1)}!`).newLine()}process.exit(0)}},Ee=class extends y{signature=`logout`;description=`Log out of Grithub CLI`;async handle(){let[e,t]=P();t(this);let n=this.spinner(`Logging out...`).start();try{await U(1e3,()=>Q()),n.succeed(`Logged out successfully`)}catch(e){n.fail(`Logout failed`),this.error(`An error occurred during logout: `+e.message)}this.newLine()}},De=class extends y{signature=`set-repo 
        { name? : The full name of the repository (e.g., username/repo)}
        {--O|org : Set repository from an organization}
    `;description=`Set the default repository.`;async handle(){let[e,n]=P();n(this);let r=M(`token`),i;if(!r)return void this.error(`ERROR: You must be logged in to set a default repository.`);if(this.argument(`name`))({data:i}=await R().rest.repos.get({owner:this.argument(`name`).split(`/`)[0],repo:this.argument(`name`).split(`/`)[1]}));else if(this.option(`org`)){let e=this.spinner(`Fetching your organizations...`).start(),t=await R().rest.orgs.listForAuthenticatedUser();e.succeed(`${t.data.length} organizations fetched successfully.`);let n=await this.choice(`Select organization`,t.data.map(e=>({name:e.login,value:e.login})),0),r=this.spinner(`Fetching repositories for organization ${n}...`).start(),a=await R().rest.repos.listForOrg({org:n});r.succeed(`${a.data.length} repositories fetched successfully.`);let o=await this.choice(`Select default repository (${M(`default_repo`)?.full_name??`none`})`,a.data.map(e=>({name:e.full_name,value:e.full_name})),0);i=a.data.find(e=>e.full_name===o)}else{let e=this.spinner(`Fetching your repositories...`).start(),t=await R().rest.repos.listForAuthenticatedUser();e.succeed(`${t.data.length} repositories fetched successfully.`);let n=await this.choice(`Select default repository (${M(`default_repo`)?.full_name??`none`})`,t.data.map(e=>({name:e.full_name,value:e.full_name})),0);i=t.data.find(e=>e.full_name===n)}i?(A(`default_repo`,{id:i.id,name:i.name,full_name:i.full_name,private:i.private}),this.info(`INFO: ${t.log(i.full_name,`blue`,!1)} has been set as the default repository.`).newLine()):(A(`default_repo`,M(`default_repo`)??{}),this.warn(`INFO: No repository selected. Default repository has been cleared.`).newLine())}};const $=w.create({baseURL:`https://api.github.com`,headers:{"Content-Type":`application/json`}}),Oe=()=>{let[e]=F(),t=e();$.defaults.baseURL=t.apiBaseURL||`https://api.github.com`,$.defaults.timeout=t.timeoutDuration||3e3};$.interceptors.request.use(e=>{let[t]=F(),[n]=P(),r=t(),i=n().getVerbosity();return(r.debug||i>1)&&((r.debug||i>=2)&&(console.log(`Request URL:`,e.url),console.log(`Request Method:`,e.method)),(r.debug||i==3)&&(console.log(`Request Headers:`,e.headers),console.log(`Request Data:`,e.data)),console.log(`Error Response URL:`,w.getUri(e))),e},e=>Promise.reject(e)),$.interceptors.response.use(e=>{let[t]=F(),[n]=P(),r=t(),i=n().getVerbosity();if(r.debug||i>1){let{data:t,status:n,statusText:a,headers:o}=e;(r.debug||i>=2)&&(console.log(`Response Data:`,t),console.log(`Response Status:`,n)),(r.debug||i===3)&&(console.log(`Response Status Text:`,a),console.log(`Response Headers:`,o)),console.log(`Error Response URL:`,w.getUri(e.config))}return e},e=>{let[t]=F(),[n]=P(),r=t(),i=n().getVerbosity();if(r.debug||i>1)if(e.response){let{data:t,status:n,headers:a}=e.response;(r.debug||i>=2)&&(console.log(`Error Response Data:`,t),console.log(`Error Response Status:`,n)),(r.debug||i===3)&&console.log(`Error Response Headers:`,a),console.log(`Error Response URL:`,w.getUri(e.config))}else console.log(`Error Message:`,e.message);return Promise.reject(e)});var ke=`
 ‚ñó‚ñÑ‚ñÑ‚ññ‚ñó‚ñÑ‚ñÑ‚ññ ‚ñó‚ñÑ‚ñÑ‚ñÑ‚ññ‚ñó‚ñÑ‚ñÑ‚ñÑ‚ññ‚ñó‚ññ ‚ñó‚ññ‚ñó‚ññ ‚ñó‚ññ‚ñó‚ñÑ‚ñÑ‚ññ 
‚ñê‚ñå   ‚ñê‚ñå ‚ñê‚ñå  ‚ñà    ‚ñà  ‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñå ‚ñê‚ñå
‚ñê‚ñå‚ñù‚ñú‚ñå‚ñê‚ñõ‚ñÄ‚ñö‚ññ  ‚ñà    ‚ñà  ‚ñê‚ñõ‚ñÄ‚ñú‚ñå‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñõ‚ñÄ‚ñö‚ññ
‚ñù‚ñö‚ñÑ‚ñû‚ñò‚ñê‚ñå ‚ñê‚ñå‚ñó‚ñÑ‚ñà‚ñÑ‚ññ  ‚ñà  ‚ñê‚ñå ‚ñê‚ñå‚ñù‚ñö‚ñÑ‚ñû‚ñò‚ñê‚ñô‚ñÑ‚ñû‚ñò                                                           
`,Ae=class{};Oe(),b.init(new Ae,{logo:ke,exceptionHandler(e){let[t]=F(),n=t();console.error(n.debug?e:e.message)},baseCommands:[_e,ve,Te,Ee,me,ye,De,xe,Se,be,ge,...de()]});export{};